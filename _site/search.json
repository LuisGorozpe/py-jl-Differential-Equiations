[
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduccion EDO con Julia",
    "section": "",
    "text": "Importar librerias\n\nimport Pkg\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")\n\nusing DifferentialEquations, Plots\n\n   Resolving package versions...\n     Project No packages added to or removed from `~/.julia/environments/v1.12/Project.toml`\n    Manifest No packages added to or removed from `~/.julia/environments/v1.12/Manifest.toml`\n   Resolving package versions...\n     Project No packages added to or removed from `~/.julia/environments/v1.12/Project.toml`\n    Manifest No packages added to or removed from `~/.julia/environments/v1.12/Manifest.toml`\n\n\n\nimport DifferentialEquations as DE # libreria para solucionar EDO con metodos numericos\nimport Plots                        # Libreria para graficar\n\n\n# Definicion de la funcion asociada a la EDO de primer orden\nf(u, p, t) = 1.01 * u\n\n# Definicion de condicion inicial\nu0 = 1 / 2\n\n# Definicion del espacio de tiempo para la solucion de la EDO\ntspan = (0.0, 1.0)\n\n# Definicion del \"objeto\" asociado a la EDO\nprob = DE.ODEProblem(f, u0, tspan)\n\n# Solucion numerica \nsol = DE.solve(prob, DE.Tsit5(), reltol = 1e-8, abstol = 1e-8)\n\n\n# Graficas de las soluciones \nPlots.plot(sol, linewidth = 5, title = \"Solution to the linear ODE with a thick line\",\n    xaxis = \"Time (t)\", yaxis = \"u(t) (in μm)\", label = \"My Thick Line!\") # legend=false\nPlots.plot!(sol.t, t -&gt; 0.5 * exp(1.01t), lw = 3, ls = :dash, label = \"True Solution!\")\n\n\n\n\n\nxs = 0:5:50\nys = -10:5:80\n\nusing LinearAlgebra, Plots\n\n# dx/dy = f(y,x)\ndf(x, y) = normalize([9.8-(y/5), 9.8-(y/5)])  \n\nxxs = [x for x in xs for y in ys]\nyys = [y for x in xs for y in ys]\n\nPlots.quiver(xxs, yys, quiver=df)\nplot!([49], seriestype=\"hline\", linestyle=:dash, color=:green, label=\"y(t)\", legend=:outerright)\n\n\n\n\n\n# Set a dark scientific theme\ntheme(:dark)\n\n# ------------------------------------------------------------------------------\n# 1. Configuration & Parameters\n# ------------------------------------------------------------------------------\nmodule Config\n    # System Parameters (Lotka-Volterra)\n    # α: prey growth, β: predation rate, δ: predator death, γ: predator growth\n    const P_SYS = (α = 1.1, β = 0.4, δ = 0.4, γ = 0.1)\n\n    # Domain Bounds\n    const X_LIM = (0.0, 15.0) # Prey population range\n    const Y_LIM = (0.0, 10.0) # Predator population range\n\n    # Grid Density for Vector Field\n    const GRID_DENSITY = 25  # Number of points per axis\n\n    # Visualization Styling\n    const ARROW_SCALE = 0.35      # visual length of arrows\n    const TRAJECTORY_TIME = (0.0, 40.0)\n    const TRAJ_COLOR = :cyan\n    const FIELD_COLOR_GRAD = :inferno\nend\n\n# ------------------------------------------------------------------------------\n# 2. ODE Definition\n# ------------------------------------------------------------------------------\n\"\"\"\n    system_dynamics!(du, u, p, t)\n\nThe differential equation definition.\nu[1] = x (Prey), u[2] = y (Predator)\n\"\"\"\nfunction system_dynamics!(du, u, p, t)\n    x, y = u\n    α, β, δ, γ = p\n\n    # dx/dt = αx - βxy\n    du[1] = α * x - β * x * y\n    \n    # dy/dt = -δy + γxy\n    du[2] = -δ * y + γ * x * y\nend\n\n# ------------------------------------------------------------------------------\n# 3. Vector Field Computation\n# ------------------------------------------------------------------------------\n\"\"\"\n    compute_vector_field(x_range, y_range, params)\n\nCalculates the vector field (U, V) and Magnitude (M) over a grid.\n\"\"\"\nfunction compute_vector_field(x_rng, y_rng, p)\n    # Create meshgrid\n    x_grid = repeat(x_rng', length(y_rng), 1)\n    y_grid = repeat(y_rng, 1, length(x_rng))\n    \n    u_grid = zeros(size(x_grid))\n    v_grid = zeros(size(y_grid))\n    mag_grid = zeros(size(x_grid))\n    \n    du = zeros(2)\n    \n    # Compute vectors at each grid point\n    for i in eachindex(x_grid)\n        state = [x_grid[i], y_grid[i]]\n        system_dynamics!(du, state, p, 0.0) # t=0 for autonomous systems\n        \n        # Calculate magnitude\n        magnitude = norm(du)\n        mag_grid[i] = magnitude\n        \n        # Normalize for visualization (prevent giant arrows)\n        # We perform a \"soft\" normalization to keep direction clear but bound length\n        if magnitude &gt; 0\n            scaling = Config.ARROW_SCALE / (magnitude^0.4) # non-linear scaling for better visuals\n            u_grid[i] = du[1] * scaling\n            v_grid[i] = du[2] * scaling\n        end\n    end\n    \n    return x_grid, y_grid, u_grid, v_grid, mag_grid\nend\n\n# ------------------------------------------------------------------------------\n# 4. Trajectory Simulation\n# ------------------------------------------------------------------------------\n\"\"\"\n    solve_trajectory(u0, params)\n\nSolves the ODE for a specific initial condition using DifferentialEquations.jl\n\"\"\"\nfunction solve_trajectory(u0, p)\n    prob = ODEProblem(system_dynamics!, u0, Config.TRAJECTORY_TIME, p)\n    # Tsit5 is a standard efficient solver for non-stiff ODEs\n    sol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\n    return sol\nend\n\n# ------------------------------------------------------------------------------\n# 5. Main Visualization Routine\n# ------------------------------------------------------------------------------\nfunction main()\n    println(\"Generating Vector Field Visualization...\")\n\n    # A. Setup Grid\n    xs = range(Config.X_LIM[1], Config.X_LIM[2], length=Config.GRID_DENSITY)\n    ys = range(Config.Y_LIM[1], Config.Y_LIM[2], length=Config.GRID_DENSITY)\n    params =Values = (Config.P_SYS.α, Config.P_SYS.β, Config.P_SYS.δ, Config.P_SYS.γ)\n\n    # B. Compute Field\n    X, Y, U, V, Mag = compute_vector_field(xs, ys, params)\n\n    # C. Initialize Plot\n    plt = plot(\n        title = \"Phase Portrait: Lotka-Volterra System\",\n        xlabel = \"Prey Population (x)\",\n        ylabel = \"Predator Population (y)\",\n        xlims = Config.X_LIM,\n        ylims = Config.Y_LIM,\n        aspect_ratio = :equal,\n        legend = :topright,\n        grid = false,\n        framestyle = :box,\n        size = (800, 600)\n    )\n\n    # D. Plot Vector Field (Quiver)\n    # We flatten the arrays because quiver expects vectors, not matrices\n    quiver!(\n        plt,\n        vec(X), vec(Y),\n        quiver = (vec(U), vec(V)),\n        color = :white,\n        alpha = 0.4,\n        linewidth = 1.0,\n        label = \"Vector Field\"\n    )\n\n    # E. Solve and Plot Trajectories\n    # Define interesting initial conditions\n    initial_conditions = [\n        [2.0, 2.0],\n        [6.0, 4.0],\n        [10.0, 8.0]\n    ]\n\n    for (i, u0) in enumerate(initial_conditions)\n        sol = solve_trajectory(u0, params)\n        plot!(plt, sol, vars=(1, 2), \n              lw=2.5, \n              color=Config.TRAJ_COLOR, \n              alpha=0.8,\n              label = i==1 ? \"Trajectories\" : \"\") # Only label the first one\n        \n        # Mark start points\n        scatter!(plt, [u0[1]], [u0[2]], \n                 color=:red, marker=:circle, markersize=4, label=nothing)\n    end\n\n    # F. Add Fixed Point (Equilibrium)\n    # For L-V: x* = δ/γ, y* = α/β\n    eq_x = Config.P_SYS.δ / Config.P_SYS.γ\n    eq_y = Config.P_SYS.α / Config.P_SYS.β\n    scatter!(plt, [eq_x], [eq_y], \n             color=:yellow, marker=:star5, markersize=8, \n             label=\"Equilibrium\")\n\n    # Display final plot\n    display(plt)\n    println(\"Visualization Complete.\")\nend\n\n# Execute\nmain()\n\nGenerating Vector Field Visualization...\nVisualization Complete.\n\n\n\n\n\n\n# ==============================================================================\n# LOGISTIC ODE VISUALIZATION\n# Script: Vector Fields, Integral Curves, and Analytical Solutions\n# Author: Gemini (Scientific Programming Assistant)\n# ==============================================================================\n\n#using DifferentialEquations\n#using Plots\n#using LinearAlgebra\n\n# ------------------------------------------------------------------------------\n# 1. PARÁMETROS Y CONFIGURACIÓN\n# ------------------------------------------------------------------------------\nconst r = 0.8          # Tasa de crecimiento\nconst K = 10.0         # Capacidad de carga\nconst t_span = (0.0, 10.0)\nconst y_range = (0.0, 15.0) # Ajustado para ver curvas por encima de K\nconst grid_density = 20\nconst y0_list = [0.5, 2.0, 5.0, 10.0, 14.0] # Condiciones iniciales\n\n# Estilo Global de Gráficos\ntheme(:dark)\nconst PLOT_STYLE = Dict(\n    :grid =&gt; true,\n    :gridalpha =&gt; 0.2,\n    :linewidth =&gt; 2,\n    :xlabel =&gt; \"Tiempo (t)\",\n    :ylabel =&gt; \"Población (y)\",\n    :legend =&gt; :outerright #,\n    #:background_color =&gt; :black\n)\n\n# ------------------------------------------------------------------------------\n# 2. DEFINICIONES MATEMÁTICAS\n# ------------------------------------------------------------------------------\n\n# La EDO Logística: dy/dt = f(y, p, t)\nfunction logistic_ode!(dy, y, p, t)\n    r_val, K_val = p\n    dy[1] = r_val * y[1] * (1 - y[1] / K_val)\nend\n\n# Solución Analítica: y(t) = K / (1 + ((K - y0)/y0) * exp(-rt))\nfunction analytical_solution(t, y0, r_val, K_val)\n    if y0 &lt;= 0\n        return 0.0\n    end\n    # Reordenado para evitar divisiones por cero innecesarias\n    term = ((K_val - y0) / y0) * exp(-r_val * t)\n    return K_val / (1 + term)\nend\n\n# ------------------------------------------------------------------------------\n# 3. FUNCIONES DE VISUALIZACIÓN\n# ------------------------------------------------------------------------------\n\n\"\"\"\nGenera el Campo Vectorial (Campo de pendientes) para la EDO.\n\"\"\"\nfunction plot_vector_field()\n    t_vals = range(t_span[1], t_span[2], length=grid_density)\n    y_vals = range(y_range[1], y_range[2], length=grid_density)\n    \n    dt_vec = Float64[]\n    dy_vec = Float64[]\n    pts_t = Float64[]\n    pts_y = Float64[]\n\n    scale = 0.3 # Escala de las flechas\n\n    for t in t_vals, y in y_vals\n        slope = r * y * (1 - y / K)\n        \n        # Normalización para uniformidad\n        mag = sqrt(1.0 + slope^2)\n        push!(dt_vec, (1.0 / mag) * scale)\n        push!(dy_vec, (slope / mag) * scale)\n        push!(pts_t, t)\n        push!(pts_y, y)\n    end\n\n    return quiver(pts_t, pts_y, quiver=(dt_vec, dy_vec), \n           color=:cyan, alpha=0.5, \n           title=\"Campo Vectorial - Ecuación Logística\",\n           xlims=t_span, ylims=y_range; \n           PLOT_STYLE...)\nend\n\n\"\"\"\nCalcula y grafica trayectorias numéricas.\n\"\"\"\nfunction plot_integral_curves()\n    p = (r, K)\n    plt = plot(title=\"Curvas Integrales (Numéricas)\", \n               xlims=t_span, ylims=y_range; \n               PLOT_STYLE...)\n    \n    colors = palette(:viridis, length(y0_list))\n    \n    for (i, y0) in enumerate(y0_list)\n        prob = ODEProblem(logistic_ode!, [y0], t_span, p)\n        sol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\n        plot!(plt, sol, vars=(0, 1), label=\"y0 = $y0\", color=colors[i])\n    end\n    \n    hline!(plt, [K], linestyle=:dash, color=:white, label=\"Capacidad K\", alpha=0.6)\n    return plt\nend\n\n\"\"\"\nGrafica las soluciones analíticas de forma cerrada.\n\"\"\"\nfunction plot_analytical_solutions()\n    plt = plot(title=\"Soluciones Analíticas (Exactas)\", \n               xlims=t_span, ylims=y_range; \n               PLOT_STYLE...)\n    \n    t_fine = range(t_span[1], t_span[2], length=200)\n    colors = palette(:magma, length(y0_list))\n\n    for (i, y0) in enumerate(y0_list)\n        y_vals = [analytical_solution(t, y0, r, K) for t in t_fine]\n        plot!(plt, t_fine, y_vals, label=\"Analítica y0=$y0\", color=colors[i])\n    end\n    \n    hline!(plt, [K], linestyle=:dash, color=:white, label=\"Capacidad K\", alpha=0.6)\n    return plt\nend\n\n# ------------------------------------------------------------------------------\n# 4. EJECUCIÓN Y COMPILACIÓN DE RESULTADOS\n# ------------------------------------------------------------------------------\n\nfunction main()\n    println(\"Generando visualizaciones... Por favor espera.\")\n    \n    # Crear los sub-gráficos\n    p1 = plot_vector_field()\n    p2 = plot_integral_curves()\n    p3 = plot_analytical_solutions()\n    \n    # Combinar en un solo layout\n    final_plot = plot(p1, p2, p3, layout=(3, 1), size=(800, 1000))\n    \n    # Mostrar el gráfico (Crucial para ejecución de script)\n    display(final_plot)\n    \n    # Opcional: Guardar el resultado\n    # savefig(final_plot, \"logistic_viz.png\")\n    \n    println(\"Visualización completada exitosamente.\")\nend\n\n# Ejecutar el script\nmain()\n\nGenerando visualizaciones... Por favor espera.\nVisualización completada exitosamente.\n\n\n\n\n\n\n\nReferencias\n\nhttps://ritog.github.io/posts/1st-order-DE-julia/1st_order_DE_julia.html\n\n\n\n\n\n\nReuseCC BY 4.0CitationBibTeX citation:@online{e._ascencio_g.,\n  author = {E. Ascencio G., Luis},\n  title = {Introduccion {EDO} Con {Julia}},\n  volume = {1},\n  number = {1},\n  doi = {000000/00000000},\n  langid = {en},\n  abstract = {En este NoteBook encontraras codigo para manejar EDO con\n    el lenguaje de programacion Julia.}\n}\nFor attribution, please cite this work as:\nE. Ascencio G., Luis. n.d. “Introduccion EDO Con Julia.”\nCIMAT. https://doi.org/000000/00000000."
  },
  {
    "objectID": "Introduction-py.html",
    "href": "Introduction-py.html",
    "title": "Introduccion EDO con Python",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\n# ==========================================\n# 1. User Definitions & Configuration\n# ==========================================\n\n# Configuration Parameters\nCONFIG = {\n    'x_range': (-3, 3),      # Domain for x\n    'y_range': (-3, 3),      # Domain for y\n    'grid_density': 25,      # Density of arrows in vector field\n    'num_integral_curves': 25, # Number of curves for Figure 2\n    'specific_ics': [-3,-2,-1,-0.5,0,0.5,1,2,3], # Specific initial conditions y(x_start) for Figure 3\n    'resolution': 500        # Resolution for numerical integration steps\n}\n\n# ==========================================\n# 2. Visualization Functions\n# ==========================================\n\ndef plot_vector_field(f, x_lim, y_lim, density=20):\n    \"\"\"\n    Figure 1: Generates the Vector Field (Slope Field).\n    \n    Mathematical Context:\n    At every point (x, y), the ODE defines a slope m = f(x,y).\n    The vector at that point is &lt;1, f(x,y)&gt;.\n    We normalize these vectors to show direction without magnitude distortion.\n    \"\"\"\n    fig = plt.figure(figsize=(10, 8))\n    \n    # Create a grid of points\n    x = np.linspace(x_lim[0], x_lim[1], density)\n    y = np.linspace(y_lim[0], y_lim[1], density)\n    X, Y = np.meshgrid(x, y)\n    \n    # Calculate vector components\n    # dx is constant (1), dy is the function output\n    U = np.ones_like(X)\n    V = f(X, Y)\n    \n    # Normalize the arrows (make them all unit length for clarity)\n    # Magnitude N = sqrt(U^2 + V^2)\n    N = np.sqrt(U**2 + V**2)\n    U = U / N\n    V = V / N\n    \n    # Plot Quiver\n    plt.quiver(X, Y, U, V, angles='xy', scale_units='xy', scale=3, color='#555555', width=0.003)\n    \n    # Styling\n    plt.title(\"Figure 1: Vector Field (Direction Field)\", fontsize=16)\n    plt.xlabel(\"x\", fontsize=14)\n    plt.ylabel(\"y\", fontsize=14)\n    plt.xlim(x_lim)\n    plt.ylim(y_lim)\n    plt.grid(True, linestyle='--', alpha=0.6)\n    plt.axhline(0, color='black', linewidth=1)\n    plt.axvline(0, color='black', linewidth=1)\n    \n    # Add equation text\n    plt.text(x_lim[0] + 0.5, y_lim[1] - 0.5, r\"$\\frac{dy}{dx} = f(x,y)$\", \n             fontsize=14, bbox=dict(facecolor='white', alpha=0.8))\n\n    plt.tight_layout()\n    plt.show()\n\ndef plot_integral_curves(f, x_lim, y_lim, num_curves=20):\n    \"\"\"\n    Figure 2: Plots a dense set of integral curves to show flow.\n    \n    Method:\n    We define a range of initial conditions along the left boundary (x_min)\n    and integrate forward to x_max using Runge-Kutta 4(5).\n    \"\"\"\n    fig = plt.figure(figsize=(10, 8))\n    \n    # Generate initial conditions along the left edge\n    y0_values = np.linspace(y_lim[0], y_lim[1], num_curves)\n    x_span = x_lim\n    \n    # Evaluation points for smooth curves\n    t_eval = np.linspace(x_lim[0], x_lim[1], CONFIG['resolution'])\n    \n    # Plot background vector field faintly for context\n    x_grid = np.linspace(x_lim[0], x_lim[1], 20)\n    y_grid = np.linspace(y_lim[0], y_lim[1], 20)\n    X, Y = np.meshgrid(x_grid, y_grid)\n    U = np.ones_like(X)\n    V = f(X, Y)\n    N = np.sqrt(U**2 + V**2)\n    plt.quiver(X, Y, U/N, V/N, alpha=0.2, color='gray')\n\n    # Solve and plot each curve\n    print(f\"Generating {num_curves} integral curves...\")\n    for y0 in y0_values:\n        # solve_ivp requires function signature fun(t, y)\n        sol = solve_ivp(f, x_span, [y0], t_eval=t_eval, method='RK45')\n        \n        if sol.success:\n            plt.plot(sol.t, sol.y[0], '-', color='teal', alpha=0.6, linewidth=1.5)\n\n    # Styling\n    plt.title(\"Figure 2: Integral Curves (General Flow)\", fontsize=16)\n    plt.xlabel(\"x\", fontsize=14)\n    plt.ylabel(\"y\", fontsize=14)\n    plt.xlim(x_lim)\n    plt.ylim(y_lim)\n    plt.grid(True, linestyle='--', alpha=0.6)\n    plt.axhline(0, color='black', linewidth=1)\n    plt.axvline(0, color='black', linewidth=1)\n\n    plt.tight_layout()\n    plt.show()\n\ndef plot_specific_solutions(f, x_lim, y_lim, initial_conditions):\n    \"\"\"\n    Figure 3: Plots specific, labeled numerical solutions.\n    \n    Use Case:\n    Highlighting specific behaviors based on exact starting points.\n    \"\"\"\n    fig = plt.figure(figsize=(10, 8))\n    \n    x_span = x_lim\n    t_eval = np.linspace(x_lim[0], x_lim[1], CONFIG['resolution'])\n    \n    colors = plt.cm.viridis(np.linspace(0, 0.9, len(initial_conditions)))\n    \n    print(\"Generating specific solutions...\")\n    for i, y0 in enumerate(initial_conditions):\n        sol = solve_ivp(f, x_span, [y0], t_eval=t_eval, method='RK45')\n        \n        if sol.success:\n            label_text = f\"$y({x_lim[0]}) = {y0}$\"\n            plt.plot(sol.t, sol.y[0], linewidth=2.5, color=colors[i], label=label_text)\n            \n            # Mark the initial condition point\n            plt.scatter([x_lim[0]], [y0], color=colors[i], s=50, zorder=5)\n\n    # Styling\n    plt.title(\"Figure 3: Specific Numerical Solutions\", fontsize=16)\n    plt.xlabel(\"x\", fontsize=14)\n    plt.ylabel(\"y\", fontsize=14)\n    plt.xlim(x_lim)\n    plt.ylim(y_lim)\n    plt.grid(True, linestyle='--', alpha=0.6)\n    plt.legend(title=\"Initial Conditions\", loc='best', frameon=True, shadow=True)\n    plt.axhline(0, color='black', linewidth=1)\n    plt.axvline(0, color='black', linewidth=1)\n\n    plt.tight_layout()\n    plt.show()\n\n# ==========================================\n# 3. Main Execution Block\n# ==========================================\n\ndef plots_ODE(ode_f):\n    print(\"--- Differential Equation Visualizer ---\")\n    print(f\"ODE: dy/dx = x - y\")\n    print(f\"Domain: x in {CONFIG['x_range']}, y in {CONFIG['y_range']}\")\n    \n    # 1. Plot Vector Field\n    plot_vector_field(\n        ode_f, \n        CONFIG['x_range'], \n        CONFIG['y_range'], \n        density=CONFIG['grid_density']\n    )\n    \n    # 2. Plot Integral Curves (Flow)\n    plot_integral_curves(\n        ode_f, \n        CONFIG['x_range'], \n        CONFIG['y_range'], \n        num_curves=CONFIG['num_integral_curves']\n    )\n    \n    # 3. Plot Specific Solutions\n    plot_specific_solutions(\n        ode_f, \n        CONFIG['x_range'], \n        CONFIG['y_range'], \n        initial_conditions=CONFIG['specific_ics']\n    )\n\n\ndef ode_f1(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx = x - y\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return -0.5*y\n\n\ndef ode_f2(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx = y^2\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return y**2\n\n\ndef ode_f3(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx =  y - sin(x)\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return y-np.sin(x)\n\n\ndef ode_f4(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx =  -x**2+np.sin(y)\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return -x**2+np.sin(y)\n\n\ndef ode_f5(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx = x**2-y\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return x**2-y\n\n\ndef ode_f6(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx =  np.sin(x-y)\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return np.sin(x-y)\n\n\ndef ode_f7(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx =  -6*x*y\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return -6*x*y\n\n\ndef ode_f8(x, y):\n    \"\"\"\n    Defines the First-Order ODE: dy/dx = f(x, y).\n    \n    Example: dy/dx = (4-2*x)/(3*y**2-5)\n    \n    Parameters:\n        x (float): Independent variable (often time).\n        y (float): Dependent variable.\n        \n    Returns:\n        float: The derivative dy/dx at (x, y).\n    \"\"\"\n    return (4-2*x)/(3*y**2-5)\n\n\nplots_ODE(ode_f1)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f2)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f3)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f4)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f5)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f6)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f7)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nplots_ODE(ode_f8)\n\n--- Differential Equation Visualizer ---\nODE: dy/dx = x - y\nDomain: x in (-3, 3), y in (-3, 3)\n\n\n\n\n\n\n\n\n\nGenerating 25 integral curves...\n\n\n\n\n\n\n\n\n\nGenerating specific solutions...\n\n\n\n\n\n\n\n\n\n\nimport session_info\n\n\nsession_info.show(html=False)\n\n-----\nmatplotlib          3.10.6\nnumpy               2.3.5\nscipy               1.16.3\nsession_info        v1.0.1\n-----\nIPython             9.7.0\njupyter_client      8.6.3\njupyter_core        5.8.1\njupyterlab          4.4.7\nnotebook            7.4.5\n-----\nPython 3.13.9 | packaged by Anaconda, Inc. | (main, Oct 21 2025, 19:16:10) [GCC 11.2.0]\nLinux-6.14.0-37-generic-x86_64-with-glibc2.39\n-----\nSession information updated at 2026-02-09 02:02\n\n\n\n\n\nReuseCC BY 4.0CitationBibTeX citation:@online{e._ascencio_g.,\n  author = {E. Ascencio G., Luis},\n  title = {Introduccion {EDO} Con {Python}},\n  volume = {1},\n  number = {1},\n  doi = {000000/00000000},\n  langid = {en},\n  abstract = {En este NoteBook encontraras codigo para manejar EDO con\n    el lenguaje de programacion Python.}\n}\nFor attribution, please cite this work as:\nE. Ascencio G., Luis. n.d. “Introduccion EDO Con Python.”\nCIMAT. https://doi.org/000000/00000000."
  }
]